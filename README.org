#+title: Ring Nexus Middleware

Middleware to support FCIS (Functional Core, Imperative Shell) style programming in ring handlers through [[https://github.com/cjohansen/nexus][Nexus]] - a zero-dependency data-driven action dispatch system.

** Why?

Classic ring handlers are hard to test and 99% of time are impure functions. The
classic ring handler goes like this:

1. Add dependencies (DB connection, client with internal secret, etc) to the
   request map (or to scope with a hoc)
2. Do impure stuff in the request handler body
3. Return a ring map based on the results

This is the "status quo" ring handler:
#+begin_src clojure
(defn hoc-handler
  [system]
  (fn [req]
    (let [db (:db system)
          input (:body req)]
      (try
        (let [result (persist-data! db input)]
          {:status 200
           :body {:success? true
                  :message "Very big success"
                  :result result}})
        (catch Exception e
            (http-response/bad-request (.getMessage e)))))))

(defn deps-on-req-handler
  [req] ;; system added to req either in middleware or route definition
  (let [db (:db req)
        input (:body req)]
    ;; same as above
    ))
#+end_src

This works, but it is hard to test independently, unless you start-up your entire component system, making your tests be at minimum integration tests or E2E tests.

Using an action dispatch system, ring handlers can become pure:

#+begin_src clojure
(defn test-handler
  [req]
  (let [db (:db req)
        input (:body req)
        stuff (get-stuff db)
        is-bad-input? (compute-bad-input req)]

    (cond
      is-bad-input?
      [[:http-response/bad-request {:message "Bad input"}]]

      (should-call-external-service? input)
      [[:service/notify input
        {:on-success [[:db/transact [(merge stuff input)]]
                      [:http-response/ok {:message "All good with notification"}]]
         :on-fail [[:http-response/internal-error {:message "Something went wrong"}]]}]]

      (should-be-parallel? req)
      [[:process/parallel ;; parallel execution of the actions/effects
        [[:service/notify input]
         [:http-response/ok {:message "Request issued"}]]]]


      :else ;; All good, actions executed sequentially
      [[:db/transact [input]]
       [:http-response/ok {:message "All good!"}]])))
#+end_src

*NOTE*: In the above example, the DB is a pure snapshot (like datomic). For SQL dbs, there needs to be a pre-requisite step of getting all of the required info from the DB

** Getting started

#+begin_src
 com.ovistoica/ring-nexus-middleware {:mvn/version "2025.07.14"}
#+end_src

*** Basic usage

#+begin_src clojure
(def store (atom {}))

;; See https://github.com/cjohansen/nexus for all config options for nexus
(def nexus {:nexus/system->state deref,
            :nexus/effects {:effects/save
                              (fn [_ store path v]
                                (swap! store assoc-in path v))}})

(defn handler
  [req]
  [[:effects/save [:it] "works!"]
   [:http-response/ok {:message "Saved to state"}]])

(def nexus-handler (wrap-nexus #'handler nexus store))

(nexus-handler dummy-req) ;; => {:status 200 :body {:message "Saved to state"}}

@store ;; => {:it "works!"}
#+end_src




*** Fetch google page example. See example code

#+begin_src clojure
(ns ring-nexus-middleware-examples.google-page
  (:require [hato.client :as http]
            [ring-nexus-middleware.core :refer [wrap-nexus]]
            [ring.adapter.jetty :as jetty]
            [ring.middleware.params])
  (:import (clojure.lang ExceptionInfo)))

(def store (atom {}))

(defn get*
  "Util used to get keys from placeholder data"
  [m k]
  (if (vector? k) (get-in m k) (get m k)))

(def nexus
  {:nexus/system->state deref,
   :nexus/effects
     {:effects/save (fn [_ store path v] (swap! store assoc-in path v)),
      :effects/delay (fn [{:keys [dispatch]} _ ms actions]
                       (Thread/sleep ms)
                       (dispatch actions)),
      :effects/http
        (fn [{:keys [dispatch]} _ request-map & [{:keys [on-success on-fail]}]]
          (prn "Fetching request" request-map)
          (try (let [response (http/request request-map)]
                 (when (seq on-success)
                   (dispatch on-success {:http-response response})))
               (catch ExceptionInfo e
                 (when (seq on-fail)
                   (dispatch on-fail {:http-response (ex-data e)})))))},
   :nexus/placeholders {:http-response
                          (fn [{:keys [http-response]} ks]
                            (if http-response
                              (if ks (get* http-response ks) http-response)
                              ;; Return the original placeholder vector if
                              ;; no http-response
                              (if ks [:http-response ks] [:http-response])))}})

(defn fetch-google-handler
  "Fetch the main page of Google, return it as a response and store in the store"
  [{:keys [uri request-method]}]
  (if (and (= "/" uri) (= request-method :get))
    [[:effects/http {:method :get, :url "https://www.google.com"}
      {:on-success [[:effects/save [:google-page] [:http-response :body]]
                    [:http/respond
                     {:body [:http-response :body],
                      :headers {"content-type" "text/html"}}]]}]]
    [[:http-response/not-found "Not found"]]))

(defn start-server
  [port]
  (jetty/run-jetty (-> #'fetch-google-handler
                       (wrap-nexus nexus store))
                   {:port port, :join? false, :async? true}))

(defn stop-server [server] (.stop server))


(comment
  (def srv (start-server 3123))
  (stop-server srv)


  (http/request {:method :get, :url "http://localhost:3123"})


  @store ;; => {:google-page "<!doctype ...>

  ,)

#+end_src


** =ring-nexus-middleware= by default provides several ring related effects/actions:
- =:http/respond= effect - takes a ring response map and responds to the request with it-
Convenience actions over =:http/respond=
- =:http-response/ok=
- =:http-response/bad-request=
- =:http-response/unauthorized=
- =:http-response/not-found=
- =:http-response/internal-server-error=
- =:http-response/forbidden=
