#+title: Ring Nexus Middleware

Middleware to support FCIS (Functional Core, Imperative Shell) style programming in ring handlers through [[https://github.com/cjohansen/nexus][Nexus]].

** Why?

Classic ring handlers are hard to test and 99% of time are impure functions. The
classic ring handler goes like this:

1. Add dependencies (DB connection, client with internal secret, etc) to the
   request map (or to scope with a hoc)
2. Do impure stuff in the request handler body
3. Return a ring map based on the results

This is the "status quo" ring handler:
#+begin_src clojure
(defn hoc-handler
  [system]
  (fn [req]
    (let [db (:db system)
          input (:body req)]
      (try
        (let [result (persist-data! db input)]
          {:status 200
           :body {:success? true
                  :message "Very big success"
                  :result result}})
        (catch Exception e
            (http-response/bad-request (.getMessage e)))))))

(defn deps-on-req-handler
  [req] ;; system added to req either in middleware or route definition
  (let [db (:db req)
        input (:body req)]
    ;; same as above
    ))
#+end_src

This works, but it is hard to test independently, unless you start-up your entire component system, making your tests be at minimum integration tests or E2E tests.

Using an action dispatch system, ring handlers can become pure:

#+begin_src clojure
(defn test-handler
  [req]
  (let [db (:db req)
        input (:body req)
        stuff (get-stuff db)
        is-bad-input? (compute-bad-input req)]

    (cond
      is-bad-input?
      [[:http-response/bad-request {:message "Bad input"} ]]

      (should-call-external-service? input)
      [[:service/notify input
        {:on-success [[:db/transact [(merge stuff input)]]
                      [:http-response/ok {:message "All good with notification"}]]
         :on-fail [[:http-response/internal-error {:message "Something went wrong"}]]}]]

      (should-be-parallel? req)
      [[:process/parallel ;; parallel execution of the actions/effects
        [[:service/notify input]
         [:http-response/ok {:message "Request issued"}]]]]


      :else ;; All good, actions executed sequentially
      [[:db/transact [input]]
       [:http-response/ok {:message "All good!"}]])))
#+end_src

*NOTE*: In the above example, the DB is a pure snapshot (like datomic). For SQL dbs, there needs to be a pre-requisite step of getting all of the required info from the DB

** Getting started

#+begin_src
 com.ovistoica/ring-nexus-middleware {:mvn/version "2025.07.14"}
#+end_src

*** Basic usage

#+begin_src clojure
(def store (atom {}))
(def nexus {:nexus/system->state deref,
            :nexus/effects {:effects/save
                              (fn [_ store path v]
                                (swap! store assoc-in path v))}})

(defn handler
  [req]
  [[:effects/save [:it] "works!"]
   [:http-response/ok {:message "Saved to state"}]])

(def nexus-handler (wrap-nexus #'handler nexus store))

(nexus-handler dummy-req) ;; => {:status 200 :body {:message "Saved to state"}}

@store ;; => {:it "works!"}
#+end_src


** =ring-nexus-middleware= by default provides several ring related effects/actions:
- =:http/respond= effect - takes a ring response map and responds to the request with it-
Convenience actions over =:http/respond=
- =:http-response/ok=
- =:http-response/bad-request=
- =:http-response/unauthorized=
- =:http-response/not-found=
- =:http-response/internal-server-error=
- =:http-response/forbidden=
