#+title: Ring Nexus Middleware

Middleware to support FCIS (Functional Core, Imperative Shell) style programming in ring handlers through [[https://github.com/cjohansen/nexus][Nexus]] - a zero-dependency data-driven action dispatch system.

** Why?

Classic ring handlers are hard to test and 99% of time are impure functions. The
classic ring handler goes like this:

1. Add dependencies (DB connection, client with internal secret, etc) to the
   request map (or to scope with a hoc)
2. Do impure stuff in the request handler body
3. Return a ring map based on the results

This is the "status quo" ring handler:
#+begin_src clojure
(defn hoc-handler
  [system]
  (fn [req]
    (let [db (:db system)
          input (:body req)]
      (try
        (let [result (persist-data! db input)]
          {:status 200
           :body {:success? true
                  :message "Very big success"
                  :result result}})
        (catch Exception e
            (http-response/bad-request (.getMessage e)))))))

(defn deps-on-req-handler
  [req] ;; system added to req either in middleware or route definition
  (let [db (:db req)
        input (:body req)]
    ;; same as above
    ))
#+end_src

This works, but it is hard to test independently, unless you start-up your entire component system, making your tests be at minimum integration tests or E2E tests.

Using an action dispatch system, ring handlers can become pure:

#+begin_src clojure
(defn test-handler
  [req]
  (let [db (:db req)
        input (:body req)
        stuff (get-stuff db)
        is-bad-input? (compute-bad-input req)]

    (cond
      is-bad-input?
      [[:http-response/bad-request {:message "Bad input"}]]

      (should-call-external-service? input)
      [[:service/notify input
        {:on-success [[:db/transact [(merge stuff input)]]
                      [:http-response/ok {:message "All good with notification"}]]
         :on-fail [[:http-response/internal-error {:message "Something went wrong"}]]}]]

      (should-be-parallel? req)
      [[:process/parallel ;; parallel execution of the actions/effects
        [[:service/notify input]
         [:http-response/ok {:message "Request issued"}]]]]


      :else ;; All good, actions executed sequentially
      [[:db/transact [input]]
       [:http-response/ok {:message "All good!"}]])))
#+end_src

*NOTE*: In the above example, the DB is a pure snapshot (like datomic). For SQL dbs, there needs to be a pre-requisite step of getting all of the required info from the DB

** Getting started

#+begin_src
 com.ovistoica/ring-nexus-middleware {:mvn/version "2025.07.14"}
#+end_src

*** Basic usage

#+begin_src clojure
(def store (atom {}))

;; See https://github.com/cjohansen/nexus for all config options for nexus
(def nexus {:nexus/system->state deref,
            :nexus/effects {:effects/save
                              (fn [_ store path v]
                                (swap! store assoc-in path v))}})

(defn handler
  [req]
  [[:effects/save [:it] "works!"]
   [:http-response/ok {:message "Saved to state"}]])

(def nexus-handler (wrap-nexus #'handler nexus store))

(nexus-handler dummy-req) ;; => {:status 200 :body {:message "Saved to state"}}

@store ;; => {:it "works!"}
#+end_src




*** Fetch google page example. See [[./examples/src/ring_nexus_middleware_examples/google_page.clj][example code]]

#+begin_src clojure
(ns ring-nexus-middleware-examples.google-page
  (:require [hato.client :as http]
            [ring-nexus-middleware.core :refer [wrap-nexus]]
            [ring.adapter.jetty :as jetty]
            [ring.middleware.params])
  (:import (clojure.lang ExceptionInfo)))

(def store (atom {}))

(defn get*
  "Util used to get keys from placeholder data"
  [m k]
  (if (vector? k) (get-in m k) (get m k)))

(def nexus
  {:nexus/system->state deref,
   :nexus/effects
     {:effects/save (fn [_ store path v] (swap! store assoc-in path v)),
      :effects/delay (fn [{:keys [dispatch]} _ ms actions]
                       (Thread/sleep ms)
                       (dispatch actions)),
      :effects/http
        (fn [{:keys [dispatch]} _ request-map & [{:keys [on-success on-fail]}]]
          (prn "Fetching request" request-map)
          (try (let [response (http/request request-map)]
                 (when (seq on-success)
                   (dispatch on-success {:http-response response})))
               (catch ExceptionInfo e
                 (when (seq on-fail)
                   (dispatch on-fail {:http-response (ex-data e)})))))},
   :nexus/placeholders {:http-response
                          (fn [{:keys [http-response]} ks]
                            (if http-response
                              (if ks (get* http-response ks) http-response)
                              ;; Return the original placeholder vector if
                              ;; no http-response
                              (if ks [:http-response ks] [:http-response])))}})

(defn fetch-google-handler
  "Fetch the main page of Google, return it as a response and store in the store"
  [{:keys [uri request-method]}]
  (if (and (= "/" uri) (= request-method :get))
    [[:effects/http {:method :get, :url "https://www.google.com"}
      {:on-success [[:effects/save [:google-page] [:http-response :body]]
                    [:http/respond
                     {:body [:http-response :body],
                      :headers {"content-type" "text/html"}}]]}]]
    [[:http-response/not-found "Not found"]]))

(defn start-server
  [port]
  (jetty/run-jetty (-> #'fetch-google-handler
                       (wrap-nexus nexus store))
                   {:port port, :join? false, :async? true}))

(defn stop-server [server] (.stop server))


(comment
  (def srv (start-server 3123))
  (stop-server srv)


  (http/request {:method :get, :url "http://localhost:3123"})


  @store ;; => {:google-page "<!doctype ...>

  ,)

#+end_src


** Default actions
 =ring-nexus-middleware= by default provides several ring related effects/actions:

- =:http/respond= effect - takes a ring response map and responds to the request with it-
Convenience actions over =:http/respond=
- =:http-response/ok=
- =:http-response/bad-request=
- =:http-response/unauthorized=
- =:http-response/not-found=
- =:http-response/internal-server-error=
- =:http-response/forbidden=

** State snapshot

It's useful to have a state snapshot in the request, as we do in [[https://github.com/cjohansen/nexus#pure-actions][pure nexus
actions]]. To achieve this, =ring-nexus-middleware= provides a snapshot of the
state at the time of the request. The default key is =:ring-nexus/state=:

#+begin_src clojure
(require '[ring-nexus-middleware :as ring-nexus])

(def store (atom {:hello :world}))

(def nexus
  {:nexus/system->state deref, ;; take store and get a snapshot
   :nexus/effects {:effects/save (fn [_ store path v]
                                   (swap! store assoc-in path v))}})

(defn print-state-handler
  [req]
  (let [state (:nexus-ring/state req)] ;; pure snapshot
    [[:http-response/ok state]]))

(ring-nexus/wrap-nexus print-state-handler nexus store)

#+end_src



The state key can also be changed:

#+begin_src clojure
(require '[ring-nexus-middleware :as ring-nexus])

(defn create-user
  [req]
  (let [user-input (:body req)
        state (:my.cool/state req)]
    (if (conflict-input? state (:body req))
      [[:http-response/bad-request {:message "Email aleary exists"}]]
      [[:effects/save [:users (:email user-input)] user-input]
       [:http-response/ok {:message "User saved succesfully"}]])))

(ring-nexus/wrap-nexus create-user nexus store {::ring-nexus/state-k :my.cool/state})
#+end_src

** Recommendations

*** Be careful using =nexus.registry= when using =nexus= both on frontend & backend

All of your actions/effects will be combined in the same registry, which can
cause conflicts. You can either:
1. Use the registry in one scenario and a nexus map in the other
2. Create separate registries for frontend & backend

*** Read multiple times, write once

Given the nature of FCIS, you cannot have multiple writes throughout the handler
so you need to structure your logic so you can be fine with this.-

*** Use an immutable DB like datomic

This recommandation is not a must but it helps to have an entire snapshot of
your DB in the handler on which you can make assertions.

To replicate this with an SQL DB, you'd have to put a middleware before the
final handler that receives the queries you need and puts the result into the
request map.

** Acknowledgments

This library couldn't be possible without the work of [[https://magnars.com][Magnar Sveen]] ([[https://github.com/magnars][[cite/t:@magnars]]]),
[[https://cjohansen.no][Christian Johansen]] ([[https://github.com/cjohansen][[cite/t:@cjohansen]]]), [[https://play.teod.eu/][Teodor Heggelund]] ([[https://github.com/teodorlu][[cite/t:@teodorlu]]])
and [[https://www.booleanknot.com/][James Reeves]] ([[https://github.com/weavejester][@weavejester]])


** License: MIT

Copyright Â© 2025 Ovidiu Stoica
Distributed under the [MIT License](https://opensource.org/license/mit).
